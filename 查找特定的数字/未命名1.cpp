//这道题当然可以遍历数组来寻找，但如果数据过多的情况下肯定会变慢
//这种时候，可以采用“哨兵查找法”
//假设n=5，数字为1，2，3，4，7。要找的是3.
//因为下标从0开始，输入后结果为a[0]=1.a[1]=2.a[2]=3.a[3]=4.a[4]=7
//所以我们可以用a[n]=x;即是a[5]=3.这样也不破坏原来数组
//这个a[n]就是我们的“哨兵”！
//接下来遍历数组，如果不等于x，就一直推进，直到遇到相等的，退出循环
//然后判断。如果p已经等于n了，就意味着数组中没有那个x，所谓遇到的相等的
//只是我们的那个“哨兵”罢了
//如果p没有等于n，说明在数组内部遇到了与“哨兵”一样的数字，就是我们
//要找的那个数，此时输出下标p即可。




#include<bits/stdc++.h>
using namespace std;

int main(void)
{
	int n,a[10005],x,p=0;
	cin>>n;
	for(int i=0;i<n;i++) cin>>a[i];
	cin>>x;
	a[n]=x;//将数组的边界定为要寻找的数字
	while(a[p]!=x) p++;
	if(p==n)  cout<<"-1";
	else cout<<p;
	
	
	return 0;
}